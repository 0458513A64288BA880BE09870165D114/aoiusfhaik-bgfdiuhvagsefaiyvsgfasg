local runservice = game:GetService('RunService')
local inputservice = game:GetService('UserInputService')
local TweenService = game:GetService('TweenService')
local camera = workspace.CurrentCamera

local last_render = 0

-- Crosshair configuration
getgenv().crosshair = {
    enabled = true,
    sticky = false,
    refreshrate = 0,
    mode = 'Mouse',
    attach_to_target = false,
    smooth_movement = true,
    smoothness_level = 50,
    firsttext = "elegant",
    secondtext = ".hvh",
    position = Vector2.new(0, 0),
    lines = 4,
    width = 1.8,
    length = 15,
    radius = 11,
    color = Color3.fromRGB(255, 255, 255),
    spin = false,
    spin_speed = 150,
    spin_max = 340,
    spin_style = Enum.EasingStyle.Circular,
    resize = false,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 50,
    resize_style = Enum.EasingStyle.Circular,
}

local drawings = {
    crosshair = {},
    text = {
        Text1 = Drawing.new('Text'),
        Text2 = Drawing.new('Text')
    }
}

-- Initialize text settings for the crosshair
drawings.text.Text1.Size = 13
drawings.text.Text1.Font = 2
drawings.text.Text1.Outline = true
drawings.text.Text1.Text = crosshair.firsttext
drawings.text.Text1.Color = Color3.new(1, 1, 1)

drawings.text.Text2.Size = 13
drawings.text.Text2.Font = 2
drawings.text.Text2.Outline = true
drawings.text.Text2.Text = crosshair.secondtext

local currentLines = crosshair.lines
local currentWidth = crosshair.width
local target_position = crosshair.position

-- Function to create the crosshair lines
local function createCrosshairLines()
    for _, line in pairs(drawings.crosshair) do
        line[1]:Remove()
        line[2]:Remove()
    end
    drawings.crosshair = {}

    for idx = 1, crosshair.lines do
        local outline = Drawing.new('Line')
        outline.Color = Color3.new(0, 0, 0)
        outline.Thickness = crosshair.width + 2
        outline.ZIndex = 1

        local inline = Drawing.new('Line')
        inline.Color = crosshair.color
        inline.Thickness = crosshair.width
        inline.ZIndex = 2

        drawings.crosshair[idx] = {outline, inline}
    end
end

createCrosshairLines()

-- Function to calculate the position based on angle and radius
function solve(angle, radius)
    return Vector2.new(
        math.sin(math.rad(angle)) * radius,
        math.cos(math.rad(angle)) * radius
    )
end

-- Smooth position calculation function
local function smoothPosition(current, target, smoothness)
    return current:Lerp(target, math.clamp(smoothness / 500, 0.01, 0.3))
end

-- Function to update crosshair position
local function updatePosition()
    if crosshair.attach_to_target and targetPart then
        local targetPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
        if onScreen then
            target_position = Vector2.new(targetPosition.X, targetPosition.Y)
        else
            target_position = camera.ViewportSize / 2
        end
    else
        target_position = (
            crosshair.mode == 'Middle' and camera.ViewportSize / 2 or
            crosshair.mode == 'Mouse' and inputservice:GetMouseLocation() or
            crosshair.position
        )
    end

    if crosshair.smooth_movement then
        crosshair.position = smoothPosition(crosshair.position, target_position, crosshair.smoothness_level)
    else
        crosshair.position = target_position
    end
end

-- Main loop to update crosshair every frame
runservice.PostSimulation:Connect(function()
    local _tick = tick()

    if _tick - last_render > crosshair.refreshrate then
        last_render = _tick

        if currentLines ~= crosshair.lines or currentWidth ~= crosshair.width then
            currentLines = crosshair.lines
            currentWidth = crosshair.width
            createCrosshairLines()
        end

        updatePosition()

        local position = crosshair.position
        local text_1 = drawings.text.Text1
        local text_2 = drawings.text.Text2

        text_1.Visible = crosshair.enabled
        text_2.Visible = crosshair.enabled

        if crosshair.enabled then
            local text_x = text_1.TextBounds.X + text_2.TextBounds.X
            text_1.Position = position + Vector2.new(-text_x / 2, crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 15)
            text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X)
            text_2.Color = crosshair.color

            for idx = 1, crosshair.lines do
                local outline = drawings.crosshair[idx][1]
                local inline = drawings.crosshair[idx][2]

                local angle = (idx - 1) * (360 / crosshair.lines)
                local length = crosshair.length

                if crosshair.spin then
                    local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                    angle = angle + tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) * 360
                end

                if crosshair.resize then
                    local resize_progress = math.abs(math.sin(math.rad(_tick * crosshair.resize_speed)))
                    local resize_length = tweenservice:GetValue(resize_progress, crosshair.resize_style, Enum.EasingDirection.InOut)
                    length = crosshair.resize_min + resize_length * (crosshair.resize_max - crosshair.resize_min)
                end

                inline.Visible = true
                inline.Color = crosshair.color
                inline.From = position + solve(angle, crosshair.radius)
                inline.To = position + solve(angle, crosshair.radius + length)
                inline.Thickness = crosshair.width

                outline.Visible = true
                outline.From = position + solve(angle, crosshair.radius - 1)
                outline.To = position + solve(angle, crosshair.radius + length + 1)
                outline.Thickness = crosshair.width + 1.5    
            end
        else
            for idx = 1, crosshair.lines do
                drawings.crosshair[idx][1].Visible = false -- Outline
                drawings.crosshair[idx][2].Visible = false -- Inline
            end
        end
    end
end)

-- Function to follow mouse (if crosshair.mode is 'Mouse')
local function cirFollowMouse()
    inputservice.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and crosshair.enabled then
            local targetX = input.Position.X - (crosshair.radius / 2)
            local targetY = input.Position.Y - (crosshair.radius / 2)

            if crosshair.smooth_movement then
                local smoothness = math.clamp(crosshair.smoothness_level / 500, 0.01, 0.3)
                local tweenInfo = TweenInfo.new(smoothness, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                -- Create a tween for smooth movement (if enabled)
                local tween = TweenService:Create(drawings.crosshair[1][2], tweenInfo, {Position = UDim2.new(0, targetX, 0, targetY)})
                tween:Play()
            else
                -- Directly set position (no smooth movement)
                drawings.crosshair[1][2].Position = UDim2.new(0, targetX, 0, targetY)
            end
        end
    end)
end

-- Attach crosshair to target part
local function attachCrosshairToTarget()
    if crosshair.attach_to_target and targetPart then
        local targetPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
        if onScreen then
            local targetX = targetPosition.X - (crosshair.radius / 2)
            local targetY = targetPosition.Y - 60 - (crosshair.radius / 2)

            if crosshair.smooth_movement then
                local smoothness = math.clamp(crosshair.smoothness_level / 500, 0.01, 0.3)
                local tweenInfo = TweenInfo.new(smoothness, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                -- Create a tween for smooth movement
                local tween = TweenService:Create(drawings.crosshair[1][2], tweenInfo, {Position = UDim2.new(0, targetX, 0, targetY)})
                tween:Play()
            else
                -- Directly set position
                drawings.crosshair[1][2].Position = UDim2.new(0, targetX, 0, targetY)
            end
        end
    end
end

cirFollowMouse()
attachCrosshairToTarget()

return crosshair
